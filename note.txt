libco属于是非对称的协程机制，也就是当在协程A种resume到协程B，协程B在执行完成之后，会yield会协程A.具体来说的话，非对称协程他是和调用者绑定在一起的，被调用协程让出CPU时，只能够让给原调用协程,也就是协程之间地位是不对等的，被调用协程只能够返回最初调用他的协程
而对称协程在启动之后和原协程没有丝毫关系，切换之间切换的操作只有一个yield。对称协程在切换时调用器会通过调度算法去选择一个yield的目标协程

go语言近几年非常火的原因之一就是他提供的网络编程API是同步的API，这样用户使用起来就非常的方便，并且通过引入协程解决了并发的问题.go语言提供的协程属于是对称协程
libco中的协程在创建好了之后其实就和所在的线程绑定好了，它不允许不同线程之间的协程进行相互的切换
libco中的协程支持共享栈模式和独有栈模式，默认是独有栈，大小的话用于可以通过co_create的第二个参数进行设置，默认是128kb.共享栈模式在高并发的场景节省了栈空间带来的开销，但是又增加了拷贝所带来的开销

libco中的主协程负责其他协程的调度执行，它永远不会yield.它是随着stCoRoutineEnv_t一起被创建出来的,它主要负责在co_eventloop函数里面进行忙活,该函数也是调度器的核心

libco中的协程在实现上，并没有使用ucontext库来实现的原因是为了效率的原因

libco中协程需要调用yield让出CPU的场景一共有三种:
1.主动调用co_yield_ct
2.协程中调用poll/co_cond_timedwait陷入阻塞状态
3.程序中调用read、write、send、recv等系统调用陷入阻塞

重新调用resume启动协程的场景:
1.主动调用co_resume
2.poll的目标文件描述符就绪/阻塞，co_cond_timedwait等到了其他协程调用的co_cond_signal
3.read、write等IO函数执行成功或超时

主协程的co_eventloop中要处理的事件包括IO事件、超时事件和挂起的协程

write函数一般不会返回0，当他的返回值 = 0时，就代表传入的第三个参数的值，也就是要写入的字节数 = 0

libco中没有使用ucontex来完成协程的上下文切花，而是自己编写了一套汇编代码来进行上下文切换.libco中的协程在上下文切换的时，只需要保存和切换少量的CPU寄存器的时和栈指针,而ucontex中，在进行协程上下文切换的时候，还需要额外的对信号屏蔽掩码和浮点数上下文进行切换.libco中取消信号屏蔽掩码的原因是为了一次系统调用，取消浮点数的原因是因为在服务器编程中，几乎是用不到浮点数的.据测试，libco中上下文切换的效率是ucontext的3.6倍左右.所以可以看出，libco牺牲了通用性来换取极致的效率

同步API风格的优点是代码逻辑清晰、易于编写并且支持业务快速迭代敏捷开发,缺点就是会容易导致程序陷入阻塞状态，从而使得程序的运行效率降低,影响到系统的并发性能.libco消除了同步操作的缺点，并且还保持着同步编程的优点.libco将协程的让出和恢复作为异步网络IO中的一次事件注册与回调,当业务逻辑遇到同步网络请求的时候，libco会将本次网络请求注册为异步事件,然后从当前协程yield出去，一直知道注册的事件发生或者超时的时候，才会通过注册的回调函数resume回来.事件的注册和回调其实就是协程的让出和恢复

libco中协程的调度策略很简洁，单个协程限定在固定的协程内部，仅在网络IO等待阻塞时切出，在网络IO事件触发时切回.libco中实现千万级协程并发的策略是依赖于共享栈的机制，也就是若干个协程共享同一个运行栈.libco创建的协程默认是独有栈，大小是128k，大小用户可以自行进行设置.但是共享栈又会引入内存拷贝的开销

该协程库首先要处理的就是同步操作，同步操作的优点是代母逻辑清晰，编码简单,而缺点是并发性能不好.libco通过hook技术，保留了同步操作的优点，并且在保证无需对已有代码进行修改的情况下将同步操作转化为异步操作.hook技术的本质其实就是用用户自定义的函数替换掉系统函数，而在自定义函数内部，当需要处理同步网络请求时，直接将它注册为异步事件，然后yield出去，一直到注册的事件发生/超时时，才会resume回来.它其实就是将协程的让出和恢复作为事件的注册和回调

协程我们可以将它看作是用户态的轻量级线程，它的创建、销毁和切换都是在用户空间完成的，对于内核而言，他甚至都不知道协程的存在.所以内核分配CPU还是按照线程来分配的CPU,也就是我们在一个线程中创建的协程共享所在线程的CPU资源,协程之间不能够并发运行.所以协程一般是使用在网络IO的服务器上的，他对CPU的要求不是很高.
