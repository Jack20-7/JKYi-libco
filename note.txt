libco属于是非对称的协程机制，也就是当在协程A种resume到协程B，协程B在执行完成之后，会yield会协程A.具体来说的话，非对称协程他是和调用者绑定在一起的，被调用协程让出CPU时，只能够让给原调用协程,也就是协程之间地位是不对等的，被调用协程只能够返回最初调用他的协程
而对称协程在启动之后和原协程没有丝毫关系，切换之间切换的操作只有一个yield。对称协程在切换时调用器会通过调度算法去选择一个yield的目标协程

go语言近几年非常火的原因之一就是他提供的网络编程API是同步的API，这样用户使用起来就非常的方便，并且通过引入协程解决了并发的问题.go语言提供的协程属于是对称协程
libco中的协程在创建好了之后其实就和所在的线程绑定好了，它不允许不同线程之间的协程进行相互的切换
libco中的协程支持共享栈模式和独有栈模式，默认是独有栈，大小的话用于可以通过co_create的第二个参数进行设置，默认是128kb.共享栈模式在高并发的场景节省了栈空间带来的开销，但是又增加了拷贝所带来的开销

libco中的主协程负责其他协程的调度执行，它永远不会yield.它是随着stCoRoutineEnv_t一起被创建出来的,它主要负责在co_eventloop函数里面进行忙活,该函数也是调度器的核心

libco中的协程在实现上，并没有使用ucontext库来实现的原因是为了效率的原因

libco中协程需要调用yield让出CPU的场景一共有三种:
1.主动调用co_yield_ct
2.协程中调用poll/co_cond_timedwait陷入阻塞状态
3.程序中调用read、write、send、recv等系统调用陷入阻塞

重新调用resume启动协程的场景:
1.主动调用co_resume
2.poll的目标文件描述符就绪/阻塞，co_cond_timedwait等到了其他协程调用的co_cond_signal
3.read、write等IO函数执行成功或超时

主协程的co_eventloop中要处理的事件包括IO事件、超时事件和挂起的协程

write函数一般不会返回0，当他的返回值 = 0时，就代表传入的第三个参数的值，也就是要写入的字节数 = 0

libco中没有使用ucontex来完成协程的上下文切花，而是自己编写了一套汇编代码来进行上下文切换.libco中的协程在上下文切换的时，只需要保存和切换少量的CPU寄存器的时和栈指针,而ucontex中，在进行协程上下文切换的时候，还需要额外的对信号屏蔽掩码和浮点数上下文进行切换.libco中取消信号屏蔽掩码的原因是为了一次系统调用，取消浮点数的原因是因为在服务器编程中，几乎是用不到浮点数的.据测试，libco中上下文切换的效率是ucontext的3.6倍左右.所以可以看出，libco牺牲了通用性来换取极致的效率
